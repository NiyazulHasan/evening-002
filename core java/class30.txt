Method overloading 
===================
Having same method name with different parameters/signatures in a single class is called method overloading.

All the methods which are present in a class are called overloaded methods.

Method overloading will reduce complexity of the programming.

ex:
---
class MeeSeva 
{
	//overloaded methods 
	public void search(int voterId)
	{
		System.out.println("Details Found via VoterId");
	}
	public void search(String houseNo)
	{
		System.out.println("Details Found via houseNo");
	}
	public void search(long aadharNo)
	{
		System.out.println("Details Found via aadharNo");
	}
}
class Test  
{
	public static void main(String[] args) 
	{
		MeeSeva ms = new MeeSeva();
		ms.search(101);
		ms.search("1-6-7/1/A");
		ms.search(1234L);
		
	}
}

Method Overriding 
==================
Having same method name with same parameters in two different classes is called method overriding.

Methods which are present in parent class are called overridden methods.

Methods which are present in child class are called overriding methods.

ex:
---
class Parent 
{
	//overridden methods
	public void property()
	{
		System.out.println("Cash+Gold+Land");
	}
	public void marry()
	{
		System.out.println("subhalakshmi");
	}
}
class Child extends Parent 
{
	//overriding methods
	@Override 
	public void marry()
	{
		System.out.println("Rashmika");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p = new Parent();
		p.property(); // Cash+Gold+Land
		p.marry(); // Subhalakshmi
		
		Child c = new Child();
		c.property(); // Cash+Gold+Land
		c.marry(); // Rashmika 
		
		Parent p1 = new Child();
		p1.property(); // Cash+Gold+Land 
		p1.marry(); // Rashmika 
	}
}


If we declare any method as final then overriding of that method is not possible.

ex:
---
class Parent 
{
	//overridden methods 
	public void property()
	{
		System.out.println("Cash+Gold+Land");
	}
	public final void marry()
	{
		System.out.println("subhalakshmi");
	}
}
class Child extends Parent 
{
	//overriding methods 
	@Override 
	public void marry()
	{
		System.out.println("Rashmika");
	}
}
class Test 
{
	public static void main(String[] args)
	{
	
		Parent p1 = new Child();
		p1.property(); // Cash+Gold+Land 
		p1.marry(); // Rashmika 
	}
}
o/p:
	C.T.E : overridden method is final


Method Hiding 
=============
Method hiding is exactly same as method overriding with following differences.

Method Overriding 			Method Hiding 
-------------------			--------------
Methods must be non-static.		Methods must be static.

Method resolution will taken care by	Method resolution will taken care by 
JVM based on runtime object.		compiler based on reference type.

It is also known as dynamic 		It is also known as static polymorphism, 
polymorphism, runtime polymorphism, 	compile time polymorphism or early binding.	
late binding.

ex:
---
class Parent 
{
	public static void property()
	{
		System.out.println("Cash+Gold+Land");
	}
	public static void marry()
	{
		System.out.println("subhalakshmi");
	}
}
class Child extends Parent 
{
	public static void marry()
	{
		System.out.println("Rashmika");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p = new Child();
		p.property(); // Cash+Gold+Land 
		p.marry(); // Subhalakshmi 
	}
}


Polymorphism 
=============
Poly means many and morphism means forms.

The ability to represent in different forms is called polymorhpism.

Diagram: class30.1

The main objective of polymorphism is to provide flexibility.

In java, polymorphism divided into two types.

1) Compile time polymorphism / Static polymorphism / Early Binding 
---------------------------------
A polymorphism which exhibits at compile time is called compile time polymorphism.
Method resolution will taken care by compiler based on reference type.
ex:
	Method Overloading 
	Method Hiding  

2) Runtime polymorphism  / Dynamic polymorphism / Late Binding 
-------------------------------------------------------------
A polymorphism which exhibits at runtime is called runtime polymorphism.
Method resolution will taken care by JVM based on runtime object.
ex:
	Method overriding 


Constructors 
============
It is a special method which is used to create and initialize an object.

Having same name as class name is called constructor.

It is called when object is created.

It does not allow any return type.

It accept following modifiers.
ex:
	default 
	public 
	private 
	protected 

In java , constructors are divided in to two types.

1) User-defined constructor

2) Default constructor 

1) User-defined constructor
----------------------------
A constructor which is created by the user based on the application requirement is called user defined constructor.

It is classified into two types.

i) Zero argument constructor 

ii) Parameterized constructor 

i) Zero argument constructor
----------------------------
Suppose if we are not passing any argumen to user defined constructor then that constructor is called zero-argument constructor.

ex:
--
class Test 
{
	Test()
	{
		System.out.println("constructor");	
	}
	
	public static void main(String[] args)
	{
		System.out.println("main-method");
	}
}
o/p:
	main-method 

ex:
---

class Test 
{
	public Test()
	{
		System.out.println("constructor");	
	}
	
	public static void main(String[] args)
	{
		Test t = new Test();
		System.out.println("main-method");
	}
}
o/p:
	constructor 
	main-method 

ex:
---

class Test 
{
	private Test()
	{
		System.out.println("constructor");	
	}
	
	public static void main(String[] args)
	{
		Test t1 = new Test();
		System.out.println("main-method");
		Test t2 = new Test();
	}
}
o/p:
	constructor
	main-method
	constructor


ex:
---

class Test 
{
	protected Test()
	{
		System.out.println("constructor");	
	}
	
	public static void main(String[] args)
	{
		Test t1 = new Test();
		System.out.println("main-method");
		Test t2 = new Test();
	}
}
o/p:
	constructor
	main-method
	constructor







































  






























































































