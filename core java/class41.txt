Ways to create a thread in java
===============================
There are two ways to create a thread in java.

1) By extending Thread class 

2) By implementing Runnable interface


1) By extending Thread class
-----------------------------
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		//instantiate a thread 
		MyThread t = new MyThread();
		
		//start a thread 
		t.start();
		
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}


Thread Schedular 
================
If multiple threads are waiting for execution which thread will be execute will decided by thread schedular.

What algorithm, behaviour, mechanism used by thread schedular is depend upon JVM vendor. 

Hence we can't expect any output or execution order in multithreading.


2) By implementing Runnable interface
--------------------------------------
class MyRunnable implements Runnable 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println("child-thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyRunnable r = new MyRunnable();
		Thread t = new Thread(r); // r is a targatable interface
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("parent-thread");
		}
	}
}

Thread life cycle 
==================
Diagram: class41.1

Once if we create a thread object our thread will be in new or born state.

Once if we call t.start() method our thread goes to ready or runnable state.

If thread schedular allocates to CPU then our thread enters to running state.

Once run() method execution is completed then our thread goes to dead state.

Setting and getting name of a thread 
===================================
In java, every thread has a name explicitly provided by the programmer or automatically generated by the JVM.

We have following methods to set and get name of a thread.

ex:
	public final void setName(String name);
	public final String getName(); 

ex:
---
class MyThread extends Thread 
{
}
class Test 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getName()); // main 
		
		MyThread t = new MyThread();
		System.out.println(t.getName()); // Thread-0
		
		Thread.currentThread().setName("parent-thread");
		System.out.println(Thread.currentThread().getName());//parent-thread
		
		t.setName("child-thread");
		System.out.println(t.getName()); // child-thread
	}
}

Thread priority 
================
In java, every thread has a priority explicitly provided by the programmer or automatically generated by JVM.

We have valid range for thread priority is 1 to 10.

If we take more then 10 priority then we will get IllegalArgumentException.

Thread class defines following standard constants as thread priority.
ex:
	Thread.MAX_PRIORITY - 10
	Thread.NORM_PRIORITY - 5
	Thread.MIN_PRIORITY - 1 

A thread which is having highest priority will be executed first.

We have following methods to set and get thread priorities.
ex:
	public final void setPriority(int priority)
	public final int getPriority() 

ex:
---
class MyThread extends Thread 
{
}
class Test 
{
	public static void main(String[] args)
	{
		System.out.println(Thread.currentThread().getPriority()); // 5
		
		MyThread t = new MyThread();
		System.out.println(t.getPriority()); // 5
		
		Thread.currentThread().setPriority(10);
		System.out.println(Thread.currentThread().getPriority());//10
		
		t.setPriority(4);
		System.out.println(t.getPriority()); // 4
	}
}

Daemon thread 
=============
Deamon thread is a low priority thread which runs in a background.

The work of deamon thread is to provide services to user threads.

There are many daemon thread are running internally.
ex:
	Garbage Collector 
	Finalizer 
	Signal Dispatch 
	and etc.

Life of daemon thread is depend upon user threads because when user threads died , deamon thread will die automatically.

We can change the behaviour of deamon thread before user threads. If we change the behaviour of deamon thread after user threads then we will get runtime exception called IllegalThreadStateException.

To change the behaviour of daemon thread we need to use setDaemon(true).

To check a thread is a daemon or not we need to use isDaemon() method.

ex:
---
class MyThread extends Thread 
{
	public void run()
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(Thread.currentThread().isDaemon());
			System.out.println("Child-Thread");
		}
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread t = new MyThread();
		t.setDaemon(true);
		t.start();
		for(int i=1;i<=5;i++)
		{
			System.out.println("Parent-Thread");
		}
	}
}

Problem without synchronization 
==============================
If there is no synchronization then we will face following problems.

1) Data inconsistency 

2) Thread Interference 

ex:
---
class Table 
{
	void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		t1.start();
		t2.start();
	}
}


Synchronization 
================
A synchronized keyword is applicable for methods and blocks.

a synchronization allows only one thread to execute at a time. Hence we can achieve thread safety.

The main advantage of synchronization is we can achieve data consistency.

The main disadvantage of synchronization is waiting time of a thread will increase which effects on the performance.

Synchronization deals with lock mechanism.

Whenever a thread wants to access the object first it has to acquire the lock of it and release it when thread completes it's task.

In synchronization threads will get the lock automatically.

If there is a specific requirement then only we need to use synchronization.

If a thread is executing synchronized method then other threads are not allowed to execute another synchronized method. But they can execute non-synchronize method concurently.

ex:
---
class Table 
{
	synchronized void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		t1.start();
		t2.start();
	}
}


synchronized block 
==================
If we want to perform synchronization on specific resource of a program then we need to use synchronized block.

If we have 100 lines but we want to perform synchronization only for 10 lines then we need to use synchronized block.

If we keep all the logics inside synchronized block then synchronized method also acts like a synchronized method.

ex:
---
class Table 
{
	void printTable(int n)
	{
		synchronized(this)
		{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
		}//sync block 
	}
}
class MyThread1 extends Thread 
{
	Table t;
	MyThread1(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	Table t;
	MyThread2(Table t)
	{
		this.t=t;
	}
	public void run()
	{
		t.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Table obj = new Table();
		MyThread1 t1=new MyThread1(obj);
		MyThread2 t2=new MyThread2(obj);
		t1.start();
		t2.start();
	}
}

static synchronization 
=====================
If we declare any static method as synchronized is called static synchronization.

In static synchronization the lock will be on class but not on object.

ex:
---
class Table 
{
	synchronized static void printTable(int n)
	{
		for(int i=1;i<=5;i++)
		{
			System.out.println(n*i);
			try
			{
				Thread.sleep(2000);
			}
			catch (InterruptedException ie)
			{
				ie.printStackTrace();
			}
		}
	}
}
class MyThread1 extends Thread 
{
	public void run()
	{
		Table.printTable(5);
	}
}
class MyThread2 extends Thread 
{
	public void run()
	{
		Table.printTable(10);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MyThread1 t1=new MyThread1();
		MyThread2 t2=new MyThread2();
		t1.start();
		t2.start();
	}
}


























