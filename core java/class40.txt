Map 
====
It is a not a child interface of Collection interface.

If we want to represent group of individual objects in key and value pair then we need to use Map interface.

Key can't be duplicate but value can be duplicate.

Key and value both must be objects.

Each key and value pair is known as one entry.

Diagram: class40.1


HashMap 
========
The underlying data structure is Hashtable.

Key can't be duplicate but value can be duplicate.

Insertion order is not preserved because it takes hash code of the key.

Hetrogeneous objects are allowed for both key and value.

Null insertion is possible for both key and value.

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		HashMap hm = new HashMap();
		hm.put("one","raja");
		hm.put("nine","nelson");
		hm.put("two","steve");
		hm.put("six","kelvin");
		System.out.println(hm); //{nine=nelson, six=kelvin, one=raja, two=steve}
		
		hm.put("one","gogo");
		System.out.println(hm); //{nine=nelson, six=kelvin, one=gogo, two=steve}
		
		hm.put(10,100);
		System.out.println(hm); //{nine=nelson, six=kelvin, one=gogo, 10=100, two=steve}
		
		hm.put(null,null);
		System.out.println(hm);//{null=null, nine=nelson, six=kelvin, one=gogo, 10=100, two=steve}
	}
}

LinkedHashMap 
=============
It is a child class of HashMap class.
LinkedHashMap is exactly same as HashMap class with following differences.

HashMap					LinkedHashMap 
-----------				--------------
The underlying data structure is 	The underlying data structure is Hashtable 
Hashtable.				and LinkedList.

Insertion order is not preserved.	Insertion order is preserved.

Introduced in 1.2 version.		Introduced in 1.4 version.

ex:
---

import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		LinkedHashMap lhm = new LinkedHashMap();
		lhm.put("one","raja");
		lhm.put("nine","nelson");
		lhm.put("two","steve");
		lhm.put("six","kelvin");
		System.out.println(lhm); //{one=raja,nine=nelson,two=steve,six=kelvin}
		
		lhm.put("one","gogo");
		System.out.println(lhm); //{one=gogo,nine=nelson,two=steve,six=kelvin}
		
		lhm.put(10,100);
		System.out.println(lhm); //{one=raja,nine=nelson,two=steve,six=kelvin,10=100}
		
		lhm.put(null,null);
		System.out.println(lhm);//{one=raja,nine=nelson,two=steve,six=kelvin,10=100,null=null}
	}
}

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Map<String,String> map  = new LinkedHashMap<>();
		map.put("one","raja");
		map.put("nine","nelson");
		map.put("two","steve");
		map.put("six","kelvin");
		
		Set s = map.keySet();
		System.out.println(s); //[one, nine, two, six]
		
		Collection c = map.values();
		System.out.println(c); //[raja, nelson, steve, kelvin]
		
		Set s1 = map.entrySet();
		System.out.println(s1);//[one=raja, nine=nelson, two=steve, six=kelvin]
	}
}

TreeMap 
========
The underlying data structure is RED BLACK TREE.

key can't be duplicate but value can be duplicate.

If we depend upon default natural sorting order then key can be homogenous and comparable.

If we depend upon customized sorting order then key can be hetrogeneous and non-comparable.

Key can't be null but value can be null.

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		TreeMap<Integer,String> tm = new TreeMap<>();
		tm.put(10,"ten");
		tm.put(1,"one");
		tm.put(5,"five");
		tm.put(7,"seven");
		System.out.println(tm); //{1=one, 5=five, 7=seven, 10=ten}
		
		tm.put(1,"gogo");
		System.out.println(tm); //{1=gogo, 5=five, 7=seven, 10=ten}
		
		tm.put(6,null);
		System.out.println(tm); // {1=gogo, 5=five, 6=null, 7=seven, 10=ten}
		
		tm.put(null,"six");
		System.out.println(tm); // R.E NullPointerException
	}
}

Hashtable 
==========
The underlying data structure is Hashtable.

Key can't be duplicate but value can be duplicate.

Insertion order is not preserved because it takes descending order of the key.

Hetrogeneous objects are allowed for both key and value.

Null insertion is not possible for both key and value.

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Hashtable ht = new Hashtable();
		ht.put(1,"one");
		ht.put(10,"ten");
		ht.put(5,"five");
		System.out.println(ht); // {10=ten, 5=five, 1=one}
		
		ht.put(1,"gogo");
		System.out.println(ht); // {10=ten, 5=five, 1=gogo}
		
		ht.put("Hi",4);
		System.out.println(ht); // {10=ten, Hi=4, 5=five, 1=gogo}
		
		//ht.put(null,"six");
		//System.out.println(ht); // R.E NullPointerException
		
		//ht.put(6,null);
		//System.out.println(ht); // R.E NullPointerException
	}
}

ex:
---
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Map<Integer,String> map = Map.of(1,"one",5,"five",7,"seven");
		
		for(Map.Entry<Integer,String> entry : map.entrySet())
		{
			System.out.println(entry.getKey()+"="+entry.getValue());
		}
	}
}

Types of cursors in java
========================
Cursor is used to read objects one by one from Collections.

We have three types of cursors.

1) Enumeration 

2) Iterator 

3) ListIterator 

1) Enumeration
--------------
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Vector v = new Vector();
		for(int i=1;i<=10;i++)
		{
			v.add(i);
		}
		System.out.println(v);//[1,2,3,4,5,6,7,8,9,10]
		
		Enumeration e = v.elements();
		while(e.hasMoreElements())
		{
			Integer i = (Integer)e.nextElement();
			System.out.println(i);
		}
	}
}

2) Iterator
------------
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		ArrayList al = new ArrayList();
		for(int i=1;i<=10;i++)
		{
			al.add(i);
		}
		System.out.println(al);//[1,2,3,4,5,6,7,8,9,10]
		
		Iterator itr = al.iterator();
		while(itr.hasNext())
		{
			Integer i = (Integer)itr.next();
			System.out.println(i);
		}
	}
}

3) ListIterator 
---------------
It is a child interface of Iterator interface.

import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		ArrayList al = new ArrayList();
		for(int i=1;i<=10;i++)
		{
			al.add(i);
		}
		System.out.println(al);//[1,2,3,4,5,6,7,8,9,10]
		
		ListIterator litr = al.listIterator();
		while(litr.hasNext())
		{
			Integer i = (Integer)litr.next();
			System.out.println(i);
		}
	}
}

forEach() 
==========
It is introduced in Java 8.

It is used to read the objects one by one from Collections.

ex:
--
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		List list = List.of(7,1,4,9,2);
		list.forEach(ele -> System.out.print(ele+" "));
	}
}

ex:
----
import java.util.*;
class Test  
{
	public static void main(String[] args) 
	{
		Map map = Map.of(1,"one",2,"two",3,"three");
		map.forEach((key,value) -> System.out.println(key+"="+value));
	}
}


Multithreading 
===============
Q) What is the difference between Thread and Process?

Thread 
-------
	A thread is a leight weight sub-process.
	We can run multiple threads concurently.	
	One thread can communicate with another thread.
Process
-------
	A process is a collection of threads.
	We can run multiple processes currently.
	One process can't communicate with another process.


Q) What is multitasking?

Executing several task simultenously such concept is called multitasking.

We have two types of multitasking.

1) Thread based multitasking
--------------------------
Executing several task simultenously where each task is a same part of a program.
It is best suitable for programmatic level.

2) Process based multitasking 
------------------------------
Executing several task simultenously where each task is a independent process.
It is best suitable for OS level.


Q) What is multithreading?

Executing several threads simultenously such concept is called multithreading.

In multithreading only 10% of work should be done by a programmer and 90% of work will be done by JAVA API.

The main important application area of multithreading are

1) To implements multimedia graphics.

2) To develop video games

3) To develop animations





















