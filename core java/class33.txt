Enum 
======
Enum concept introduced in 1.5 version.

Enum is a group of named constants.

Using Enum we can create our own datatype called enumerated datatype.

When compare to old language enum, java enum is more powerful.

We can declare enum as follow.

syntax:
-------
	enum  <type_name>
	{
		value1,value2,....,valueN
	}

ex:
---
enum Months
{
	JAN,FEB,MAR
}

class Test 
{
	public static void main(String[] args) 
	{
		Months m = Months.JAN;
		System.out.println(m); 
	}
}

ex:
---
enum Drinks
{
	COLA,COKE,PEPSI
}

class Test 
{
	public static void main(String[] args) 
	{
		Drinks d = Drinks.COKE;
		switch(d)
		{
			case COLA : System.out.println("It is a COLA"); break;
			case COKE : System.out.println("It is a COKE"); break;
			case PEPSI: System.out.println("It is a PEPSI"); break;
		}
	}
}

ex:
---
enum Drinks
{
	COLA,COKE,PEPSI
}

class Test 
{
	public static void main(String[] args) 
	{
		Drinks[] d = Drinks.values();
		
		for(Drinks d1 : d)
		{
			System.out.println(d1+" --- "+d1.ordinal());	
		}
		
	}
}

When compare to old language enum , java enum is more powerful because in addition to constant we can declare constructors, variables and methods

ex:
--
enum Cloth 
{
	SILK,COTTON,KHADI;
	
	Cloth()
	{
		System.out.println("constructor");
	}
}

class Test 
{
	public static void main(String[] args) 
	{
		
		Cloth c = Cloth.SILK;
	}
}

ex:
---
enum Cloth 
{
	SILK,COTTON,KHADI;
	
	static int i = 10;
	
	public static void main(String[] args)
	{
		System.out.println(i);
	}
}

Inner classes 
=============
Sometimes we will declare a class inside another class such concept is called inner class.

ex:
	class Outer
	{
		class Inner
		{	
			-
			- //some logic 
			-
		}
	}

Inner class must be declare within enclosing class.

Inner class introduced as a part of event handling to remove GUI bugs.

But due to powerful features and benefits of inner classes programmer started to use inner classes in regular programming.

We can't declare static members in inner class.


Accessing inner class data from static area of outer class
------------------------------------------------------------
class Outer
{
	class Inner
	{
		public void m1()
		{
			System.out.println("M1-Method");
		}
	}
	
	public static void main(String[] args)
	{
		Outer.Inner i = new Outer().new Inner();
		i.m1();
	}
}


If we compile above program we will get two .class files 
i.e Outer.class and Outer$Inner.class.



Accessing inner class data from non-static area of outer class
------------------------------------------------------------
class Outer
{
	class Inner
	{
		public void m1()
		{
			System.out.println("M1-Method");
		}
	}
	
	public void m2()
	{
		Inner i = new Inner();
		i.m1();
	}
	
	public static void main(String[] args)
	{
		Outer o =new Outer();
		o.m2();
	}
}



Wrapper classes 
===============
The main objective of wrapper classes are 

1) To wrap primitive type to wrapper object and vice versa.

2) To defined several utility methods. 

ex:
	Primitive type		Wrapper class
	--------------		---------------
	byte			Byte
	short			Short
	int			Integer
	long			Long
	float			Float
	double			Double
	boolean 		Boolean 
	char 			Character 

ex:
---
class Test 
{
	public static void main(String[] args)
	{
		int i1 = Integer.valueOf(10);
		
		int i2 = Integer.valueOf("20");
		
		System.out.println(i1+" "+i2);
	}
}

ex:
---
class Test 
{
	public static void main(String[] args)
	{
		char ch = Character.valueOf('a');
		
		System.out.println(ch);//a 
	}
}

ex:
---
class Test 
{
	public static void main(String[] args)
	{
		boolean b1 = Boolean.valueOf(true);
	
		boolean b2 = Boolean.valueOf("false");	
		
		System.out.println(b1+" "+b2);
	}
}

Utility Methods 
===============
1) valueOf() 
------------
It is used to convert primitive type to wrapper object.
ex:
class Test 
{
	public static void main(String[] args)
	{
		//primitive type 
		int a=20;
		
		//wrapper object
		Integer i1 = Integer.valueOf(a);
		
		System.out.println(i1); // 20 
	}
}		
Automatic converting from primitive type to wrapper object is called autoboxing.
ex:
	int a=10;
	Integer i = a;
	System.out.println(i); // 20 

2) xxxValue()
--------------
It is used to convert wrapper object to primitive type.

ex:
---
class Test 
{
	public static void main(String[] args)
	{
		//wrapper object
		Integer i = Integer.valueOf(10);
		
		//primitive type 
		int a =  i.intValue();
		
		System.out.println(a); 
	}
}

Note:
-----
Automatic converting from wrapper object to primitive type is called autounboxing.

ex:
	Integer i = Integer.valueOf(10);	
	int a = i;
	System.out.println(a); 


3) parseXxx()
--------------
It is used to convert string type to primitive or wrapper object.
ex:
---
class Test 
{
	public static void main(String[] args)
	{
		String str="10";
		int i = Integer.parseInt(str);
		System.out.println(i); //10
		
		float f = Float.parseFloat(str);
		System.out.println(f); //10.0
	}
}

4) toString() 
-------------
It is used to convert wrapper object to string type.

ex:
---
class Test 
{
	public static void main(String[] args)
	{
		Integer i = Integer.valueOf(10);
		
		String str = i.toString();
		
		System.out.println(str); //10
	}
}

Interview Question 
==================
Q) Write a java program to perform sum of two binary numbers?

input:
	1010
	0101
output:
	1111

import java.util.Scanner;
class Test 
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.println("Enter the first binary number :");
		String binary1 = sc.next();//1010
		
		System.out.println("Enter the second binary number :");
		String binary2 = sc.next();//0101
		
		//convert binary to decimal  
		int a = Integer.parseInt(binary1,2); // 10
		int b = Integer.parseInt(binary2,2); // 5
		
		int c = a + b;
		
		//convert decimal number to binary number 
		String result = Integer.toBinaryString(c);
		System.out.println(result);
	}
}























