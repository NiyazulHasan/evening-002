finally block 
=============
It is never recommanded to maintain cleanup code in try block because if any exception raised in try block then it won't be executed.

It is never recommanded to maintain cleanup code in catch block because if there is no exception in try block then catch block won't be executed.

We need a place where we can maintain cleanup code and it should execute irrespective of exception raised or not. Such block is called finally block.

syntax:
------
	try 
	{
		- // Risky code 
	}
	catch(Exception e)
	{
		- // Error Handling code 
	}
	finally
	{
		- // Cleanup code
	}

ex:
---
class Test  
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("try-block");
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		finally
		{
			System.out.println("finally-block");
		}
	}
}
o/p:
	try-block 
	finally-block 

ex:
---
class Test  
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println(10/0);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
		finally
		{
			System.out.println("finally-block");
		}
	}
}
o/p:
	java.lang.ArithmeticException: / by zero
        at Test.main(Test.java:7)
	finally-block

ex:
---
class Test  
{
	public static void main(String[] args) 
	{
		int i=1;
		try
		{
			i++;
		}
		catch (Exception e)
		{
			i++;
		}
		finally
		{
			i++;
		}
		System.out.println(i); //3 
	}
}

In java, try with finally combination is valid.

ex:
---
class Test  
{
	public static void main(String[] args) 
	{
		try
		{
			System.out.println("try-block");
		}
		finally
		{
			System.out.println("finally-block");
		}
	}
}
o/p:
	try-block 
	finally-block 


throw statement 
================
Sometimes we will create exception object explicitly and handover to JVM manually by using throw statement.
ex:
	throw new ArithmeticException("Don't divide by zero");

Diagram: class37.1


throws statement 
=================
If any checked exception raised in our program we must and should handle that exception by using try and catch block or by using throws statement.

ex:
---
class Test  
{
	public static void main(String[] args) 
	{
		try
		{
			Thread.sleep(4000);
			System.out.println("Welcome to Java");
		}
		catch (InterruptedException ie)
		{
			ie.printStackTrace();
		}
	}
}

ex:
---
class Test  
{
	public static void main(String[] args)throws InterruptedException 
	{
			Thread.sleep(5000);
			System.out.println("Welcome to Java");
	}
}

2) User defined exceptions 
============================
Exceptions which are created by the user based on the application requirements are called userdefined exceptions or custom exceptions.

ex:
	NoPracticeNoJobException 
	NotInterestedInJavaException
	ACWorkingException 
	and etc.

ex:
---
import java.util.Scanner;
class TooYoungException extends RuntimeException 
{
	TooYoungException(String msg)
	{
		super(msg);
	}
}
class TooOldException extends RuntimeException 
{
	TooOldException(String msg)
	{
		super(msg);
	}
}
class Test  
{
	public static void main(String[] args) 
	{
		Scanner sc = new Scanner(System.in);
		System.out.println("Enter the age :");
		int age = sc.nextInt();
		if(age<18)
			throw new TooYoungException("U r not eligible to vote");
		else
			throw new TooOldException("U r eligible to vote");
	}
}

java.io package
===============
java.io package 
===============

File
======
File class checks is there any abc.txt file already exist or not. If it is not exist then it won't create any physical file.
ex:
	File f = new File("abc.txt");
ex:
---
import java.io.*;
class Test 
{
	public static void main(String[] args)
	{
		File f = new File("abc.txt");
		System.out.println(f.exists()); // false
	}
}

File object can be used to create a physical file.

ex:
---
import java.io.*;
class Test 
{
	public static void main(String[] args)throws IOException
	{
		File f = new File("abc.txt");
		System.out.println(f.exists()); // false
		
		f.createNewFile();
		System.out.println(f.exists()); // true 
	}
}

File object can be used to create a directory.

ex:
--
import java.io.*;
class Test 
{
	public static void main(String[] args)throws IOException
	{
		File f = new File("ihub");
		System.out.println(f.exists()); // false
		
		f.mkdir();
		System.out.println(f.exists()); // true 
	}
}

FileWriter 
==========
It is used to insert character oriented data into a file.

constructor 
----------
	FileWriter fw = new FileWriter(File f);
Note:
-----
	If that file is not available then FileWriter will create a physical file.

Methods
-------

1) write(int ch)
----------------
	It is used to insert single character into a file.

2) write(char[] ch)
-------------------
	It is used to insert array of characters into a file.

3) write(String s)
-------------------
	It is used to insert string into a file.

4) flush()
----------
	It gives guarante that last character of a file is also inserted.

5) close() 
---------
	It is used to close FileWriter object.

ex:
----
import java.io.*;
class Test 
{
	public static void main(String[] args)
	{
		try(FileWriter fw = new FileWriter("aaa.txt");)
		{
			fw.write(98);//b
			
			fw.write("\n");
			
			char[] ch={'a','b','c'};
			fw.write(ch);
			
			fw.write("\n");
			
			fw.write("ihub");
			
			fw.flush();
			
			System.out.println("Please check the location");
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
	}
}

FileReader 
==========
It is used to read character oriented data from a file.

constructor
-----------
	FileReader fr = new FileReader(File f);

Methods
-------

1) read()
--------
	It reads next character from a file and returns unicode value.
	If next character is not available then it will return -1.

2) read(char[] ch)
------------------
	It is used to read collection of characters from a file.

3) close()
------------
	It is used to close FileReader object.

ex:
---
import java.io.*;
class Test 
{
	public static void main(String[] args)
	{
		try(FileReader fr = new FileReader("aaa.txt");)
		{
			int i = fr.read();
			while(i!=-1)
			{
				System.out.print((char)i);
				i=fr.read();
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
	}
}

Limitations with FileWriter and FileReader 
==========================================
While inserting the data using FileWriter we need to insert line seperators(\n) which is very headache for the programmer.

While reading the data using FileReader we need to read character by character which is not convenient to the programmer.

To overcome above limitations Sun Micro System introduced BufferedWriter and BufferedReader.

BufferedWriter
---------------
It is used to insert character oriented data into a file.

constructor 
----------
	BufferedWriter bw = new BufferedWriter(Writer w);

Note:
-----
	BufferedWriter can't communicate with file directly. 
	It takes the support of Writer object.

Methods 
-------

1) write(int ch)
----------------
	It is used to insert single character into a file.

2) write(char[] ch)
-------------------
	It is used to insert array of characters into a file.

3) write(String s)
-------------------
	It is used to insert string into a file.

4) flush()
----------
	It gives guarante that last character of a file is also inserted.

5) close() 
---------
	It is used to close BufferedWriter object.

6) newLine()
------------
	It is used to insert new line in a file.

ex:
---
import java.io.*;
class Test 
{
	public static void main(String[] args)
	{
		try(BufferedWriter bw = new BufferedWriter(new FileWriter("bbb.txt"));)
		{
			bw.write(98); // b
			bw.newLine();
			
			char[] ch={'a','b','c'};
			bw.write(ch);
			bw.newLine();
			
			bw.write("talent");
			
			bw.flush();
			
			System.out.println("Please check the location");
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
	}
}

BufferedReader 
==============
It is enhanced reader to read character oriented data from a file.

constructor
-----------
	BufferedReader br = new BufferedReader(Reader r);
Note:
-----
	BufferedReader can't communicate with file directly.
	It takes the support of Reader object.

The main advantage of BufferedReader over FileReader is we can read line by line instead of character by character. 


Methods
-------

1) read()
--------
	It reads next character from a file and returns unicode value.
	If next character is not available then it will return -1.

2) read(char[] ch)
------------------
	It is used to read collection of characters from a file.

3) close()
------------
	It is used to close FileReader object.

4) readLine()
-------------
	It is used to read next line from a file.
	If next line is not available then it will return null.

ex:
---
import java.io.*;
class Test 
{
	public static void main(String[] args)
	{
		try(BufferedReader br = new BufferedReader(new FileReader("bbb.txt"));)
		{
			String line = br.readLine();
			while(line!=null)
			{
				System.out.println(line);
				line = br.readLine();
			}
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
	}
}

PrintWriter 
===========
It is enhanced writer to write character oriented data into a file.

constructor
-----------
	PrintWriter pw = new PrintWriter(Writer w);
	PrintWriter pw = new PrintWriter(File f);

Note:
-----
	PrintWriter can communicate with file directly. 
	PrintWriter can take the support of Writer object.

The main advantage of PrintWriter over FileWriter and BufferedWriter is using PrintWriter we can insert any type of data.If we have primitive values to insert then PrintWriter is recommanded to use.

methods
-------
write(int ch)
write(char[] ch)
write(String s)
flush()
close() 

print(int i)
print(char ch)
print(double d)
print(boolean b)
print(String s)

println(int i)
println(char ch)
println(double d)
println(boolean b)
println(String s)

ex:
---
import java.io.*;
class Test 
{
	public static void main(String[] args)
	{
		try(PrintWriter pw = new PrintWriter("ccc.txt");)
		{
			pw.write(98);//b
			pw.println(98);//98
			pw.println('a');//a
			pw.println(10.5d);//10.5
			pw.println(true);//true
			pw.println("Hi");//Hi
			pw.flush();
			System.out.println("Please check the location");
		}
		catch (IOException ioe)
		{
			ioe.printStackTrace();
		}
	}
}





































	

























